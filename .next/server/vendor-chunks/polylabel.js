"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polylabel";
exports.ids = ["vendor-chunks/polylabel"];
exports.modules = {

/***/ "(ssr)/./node_modules/polylabel/polylabel.js":
/*!*********************************************!*\
  !*** ./node_modules/polylabel/polylabel.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Queue = __webpack_require__(/*! tinyqueue */ \"(ssr)/./node_modules/tinyqueue/index.js\");\n\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports[\"default\"] = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    if (cellSize === 0) {\n        var degeneratePoleOfInaccessibility = [minX, minY];\n        degeneratePoleOfInaccessibility.distance = 0;\n        return degeneratePoleOfInaccessibility;\n    }\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(undefined, compareMax);\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    var poleOfInaccessibility = [bestCell.x, bestCell.y];\n    poleOfInaccessibility.distance = bestCell.d;\n    return poleOfInaccessibility;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWxhYmVsL3BvbHlsYWJlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQVc7O0FBRS9CLDBDQUEwQzs7QUFFMUM7QUFDQSx5QkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0RBQWdEO0FBQ2hELDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcG9seWxhYmVsL3BvbHlsYWJlbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBRdWV1ZSA9IHJlcXVpcmUoJ3RpbnlxdWV1ZScpO1xuXG5pZiAoUXVldWUuZGVmYXVsdCkgUXVldWUgPSBRdWV1ZS5kZWZhdWx0OyAvLyB0ZW1wb3Jhcnkgd2VicGFjayBmaXhcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5bGFiZWw7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcG9seWxhYmVsO1xuXG5mdW5jdGlvbiBwb2x5bGFiZWwocG9seWdvbiwgcHJlY2lzaW9uLCBkZWJ1Zykge1xuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAxLjA7XG5cbiAgICAvLyBmaW5kIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG91dGVyIHJpbmdcbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25bMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb2x5Z29uWzBdW2ldO1xuICAgICAgICBpZiAoIWkgfHwgcFswXSA8IG1pblgpIG1pblggPSBwWzBdO1xuICAgICAgICBpZiAoIWkgfHwgcFsxXSA8IG1pblkpIG1pblkgPSBwWzFdO1xuICAgICAgICBpZiAoIWkgfHwgcFswXSA+IG1heFgpIG1heFggPSBwWzBdO1xuICAgICAgICBpZiAoIWkgfHwgcFsxXSA+IG1heFkpIG1heFkgPSBwWzFdO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IG1heFggLSBtaW5YO1xuICAgIHZhciBoZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICB2YXIgY2VsbFNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgaCA9IGNlbGxTaXplIC8gMjtcblxuICAgIGlmIChjZWxsU2l6ZSA9PT0gMCkge1xuICAgICAgICB2YXIgZGVnZW5lcmF0ZVBvbGVPZkluYWNjZXNzaWJpbGl0eSA9IFttaW5YLCBtaW5ZXTtcbiAgICAgICAgZGVnZW5lcmF0ZVBvbGVPZkluYWNjZXNzaWJpbGl0eS5kaXN0YW5jZSA9IDA7XG4gICAgICAgIHJldHVybiBkZWdlbmVyYXRlUG9sZU9mSW5hY2Nlc3NpYmlsaXR5O1xuICAgIH1cblxuICAgIC8vIGEgcHJpb3JpdHkgcXVldWUgb2YgY2VsbHMgaW4gb3JkZXIgb2YgdGhlaXIgXCJwb3RlbnRpYWxcIiAobWF4IGRpc3RhbmNlIHRvIHBvbHlnb24pXG4gICAgdmFyIGNlbGxRdWV1ZSA9IG5ldyBRdWV1ZSh1bmRlZmluZWQsIGNvbXBhcmVNYXgpO1xuXG4gICAgLy8gY292ZXIgcG9seWdvbiB3aXRoIGluaXRpYWwgY2VsbHNcbiAgICBmb3IgKHZhciB4ID0gbWluWDsgeCA8IG1heFg7IHggKz0gY2VsbFNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IG1pblk7IHkgPCBtYXhZOyB5ICs9IGNlbGxTaXplKSB7XG4gICAgICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbCh4ICsgaCwgeSArIGgsIGgsIHBvbHlnb24pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRha2UgY2VudHJvaWQgYXMgdGhlIGZpcnN0IGJlc3QgZ3Vlc3NcbiAgICB2YXIgYmVzdENlbGwgPSBnZXRDZW50cm9pZENlbGwocG9seWdvbik7XG5cbiAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHJlY3Rhbmd1bGFyIHBvbHlnb25zXG4gICAgdmFyIGJib3hDZWxsID0gbmV3IENlbGwobWluWCArIHdpZHRoIC8gMiwgbWluWSArIGhlaWdodCAvIDIsIDAsIHBvbHlnb24pO1xuICAgIGlmIChiYm94Q2VsbC5kID4gYmVzdENlbGwuZCkgYmVzdENlbGwgPSBiYm94Q2VsbDtcblxuICAgIHZhciBudW1Qcm9iZXMgPSBjZWxsUXVldWUubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGNlbGxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGljayB0aGUgbW9zdCBwcm9taXNpbmcgY2VsbCBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICB2YXIgY2VsbCA9IGNlbGxRdWV1ZS5wb3AoKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGJlc3QgY2VsbCBpZiB3ZSBmb3VuZCBhIGJldHRlciBvbmVcbiAgICAgICAgaWYgKGNlbGwuZCA+IGJlc3RDZWxsLmQpIHtcbiAgICAgICAgICAgIGJlc3RDZWxsID0gY2VsbDtcbiAgICAgICAgICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coJ2ZvdW5kIGJlc3QgJWQgYWZ0ZXIgJWQgcHJvYmVzJywgTWF0aC5yb3VuZCgxZTQgKiBjZWxsLmQpIC8gMWU0LCBudW1Qcm9iZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gbm90IGRyaWxsIGRvd24gZnVydGhlciBpZiB0aGVyZSdzIG5vIGNoYW5jZSBvZiBhIGJldHRlciBzb2x1dGlvblxuICAgICAgICBpZiAoY2VsbC5tYXggLSBiZXN0Q2VsbC5kIDw9IHByZWNpc2lvbikgY29udGludWU7XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGNlbGwgaW50byBmb3VyIGNlbGxzXG4gICAgICAgIGggPSBjZWxsLmggLyAyO1xuICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbChjZWxsLnggLSBoLCBjZWxsLnkgLSBoLCBoLCBwb2x5Z29uKSk7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwueCArIGgsIGNlbGwueSAtIGgsIGgsIHBvbHlnb24pKTtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC54IC0gaCwgY2VsbC55ICsgaCwgaCwgcG9seWdvbikpO1xuICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbChjZWxsLnggKyBoLCBjZWxsLnkgKyBoLCBoLCBwb2x5Z29uKSk7XG4gICAgICAgIG51bVByb2JlcyArPSA0O1xuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnbnVtIHByb2JlczogJyArIG51bVByb2Jlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdiZXN0IGRpc3RhbmNlOiAnICsgYmVzdENlbGwuZCk7XG4gICAgfVxuXG4gICAgdmFyIHBvbGVPZkluYWNjZXNzaWJpbGl0eSA9IFtiZXN0Q2VsbC54LCBiZXN0Q2VsbC55XTtcbiAgICBwb2xlT2ZJbmFjY2Vzc2liaWxpdHkuZGlzdGFuY2UgPSBiZXN0Q2VsbC5kO1xuICAgIHJldHVybiBwb2xlT2ZJbmFjY2Vzc2liaWxpdHk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVNYXgoYSwgYikge1xuICAgIHJldHVybiBiLm1heCAtIGEubWF4O1xufVxuXG5mdW5jdGlvbiBDZWxsKHgsIHksIGgsIHBvbHlnb24pIHtcbiAgICB0aGlzLnggPSB4OyAvLyBjZWxsIGNlbnRlciB4XG4gICAgdGhpcy55ID0geTsgLy8gY2VsbCBjZW50ZXIgeVxuICAgIHRoaXMuaCA9IGg7IC8vIGhhbGYgdGhlIGNlbGwgc2l6ZVxuICAgIHRoaXMuZCA9IHBvaW50VG9Qb2x5Z29uRGlzdCh4LCB5LCBwb2x5Z29uKTsgLy8gZGlzdGFuY2UgZnJvbSBjZWxsIGNlbnRlciB0byBwb2x5Z29uXG4gICAgdGhpcy5tYXggPSB0aGlzLmQgKyB0aGlzLmggKiBNYXRoLlNRUlQyOyAvLyBtYXggZGlzdGFuY2UgdG8gcG9seWdvbiB3aXRoaW4gYSBjZWxsXG59XG5cbi8vIHNpZ25lZCBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIHBvbHlnb24gb3V0bGluZSAobmVnYXRpdmUgaWYgcG9pbnQgaXMgb3V0c2lkZSlcbmZ1bmN0aW9uIHBvaW50VG9Qb2x5Z29uRGlzdCh4LCB5LCBwb2x5Z29uKSB7XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIHZhciBtaW5EaXN0U3EgPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9seWdvbi5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgcmluZyA9IHBvbHlnb25ba107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmcubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICAgICAgdmFyIGEgPSByaW5nW2ldO1xuICAgICAgICAgICAgdmFyIGIgPSByaW5nW2pdO1xuXG4gICAgICAgICAgICBpZiAoKGFbMV0gPiB5ICE9PSBiWzFdID4geSkgJiZcbiAgICAgICAgICAgICAgICAoeCA8IChiWzBdIC0gYVswXSkgKiAoeSAtIGFbMV0pIC8gKGJbMV0gLSBhWzFdKSArIGFbMF0pKSBpbnNpZGUgPSAhaW5zaWRlO1xuXG4gICAgICAgICAgICBtaW5EaXN0U3EgPSBNYXRoLm1pbihtaW5EaXN0U3EsIGdldFNlZ0Rpc3RTcSh4LCB5LCBhLCBiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluRGlzdFNxID09PSAwID8gMCA6IChpbnNpZGUgPyAxIDogLTEpICogTWF0aC5zcXJ0KG1pbkRpc3RTcSk7XG59XG5cbi8vIGdldCBwb2x5Z29uIGNlbnRyb2lkXG5mdW5jdGlvbiBnZXRDZW50cm9pZENlbGwocG9seWdvbikge1xuICAgIHZhciBhcmVhID0gMDtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciBwb2ludHMgPSBwb2x5Z29uWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciBhID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgYiA9IHBvaW50c1tqXTtcbiAgICAgICAgdmFyIGYgPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuICAgICAgICB4ICs9IChhWzBdICsgYlswXSkgKiBmO1xuICAgICAgICB5ICs9IChhWzFdICsgYlsxXSkgKiBmO1xuICAgICAgICBhcmVhICs9IGYgKiAzO1xuICAgIH1cbiAgICBpZiAoYXJlYSA9PT0gMCkgcmV0dXJuIG5ldyBDZWxsKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdLCAwLCBwb2x5Z29uKTtcbiAgICByZXR1cm4gbmV3IENlbGwoeCAvIGFyZWEsIHkgLyBhcmVhLCAwLCBwb2x5Z29uKTtcbn1cblxuLy8gZ2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gZ2V0U2VnRGlzdFNxKHB4LCBweSwgYSwgYikge1xuXG4gICAgdmFyIHggPSBhWzBdO1xuICAgIHZhciB5ID0gYVsxXTtcbiAgICB2YXIgZHggPSBiWzBdIC0geDtcbiAgICB2YXIgZHkgPSBiWzFdIC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChweCAtIHgpICogZHggKyAocHkgLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gYlswXTtcbiAgICAgICAgICAgIHkgPSBiWzFdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHB4IC0geDtcbiAgICBkeSA9IHB5IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polylabel/polylabel.js\n");

/***/ })

};
;